FullStack Intern Coding Challenge 
Tech Stack 
● Backend: Any one of backend framework from this ExpressJs/Loopback/NestJs ● Database: PostgreSQL/MySQL/SQL lite
● Frontend: ReactJs 
Requirements 
We need a web application that allows users to submit ratings for stores registered on the platform. The ratings should range from 1 to 5. 
A single login system should be implemented for all users. Based on their roles, users will have access to different functionalities upon logging in. 
Normal users should be able to sign up on the platform through a registration page. User Roles 
1. System Administrator 
2. Normal User 
3. Store Owner 
Functionalities 
System Administrator 
● Can add new stores, normal users, and admin users. 
● Has access to a dashboard displaying: 
○ Total number of users 
○ Total number of stores 
○ Total number of submitted ratings 
● Can add new users with the following details: 
○ Name 
○ Email 
○ Password 
○ Address 
● Can view a list of stores with the following details: 
○ Name, Email, Address, Rating 
● Can view a list of normal and admin users with: 
○ Name, Email, Address, Role 
● Can apply filters on all listings based on Name, Email, Address, and Role. ● Can view details of all users, including Name, Email, Address, and Role. ○ If the user is a Store Owner, their Rating should also be displayed. ● Can log out from the system. 
Normal User
● Can sign up and log in to the platform. 
● Signup form fields: 
○ Name 
○ Email 
○ Address 
○ Password 
● Can update their password after logging in. 
● Can view a list of all registered stores. 
● Can search for stores by Name and Address. 
● Store listings should display: 
○ Store Name 
○ Address 
○ Overall Rating 
○ User's Submitted Rating 
○ Option to submit a rating 
○ Option to modify their submitted rating 
● Can submit ratings (between 1 to 5) for individual stores. 
● Can log out from the system. 
Store Owner 
● Can log in to the platform. 
● Can update their password after logging in. 
● Dashboard functionalities: 
○ View a list of users who have submitted ratings for their store. 
○ See the average rating of their store. 
● Can log out from the system. 
Form Validations 
● Name: Min 20 characters, Max 60 characters. 
● Address: Max 400 characters. 
● Password: 8-16 characters, must include at least one uppercase letter and one special character. 
● Email: Must follow standard email validation rules. 
Additional Notes 
● All tables should support sorting (ascending/descending) for key fields like Name, Email, etc. 
● Best practices should be followed for both frontend and backend development. ● Database schema design should adhere to best practices.




# Roxiler Assignment Reference Document

---

This document outlines the requirements and guidelines for the FullStack Intern Coding Challenge. The goal is to build a web application for submitting and managing store ratings, with role-based access for different users.

## Tech Stack Overview

- **Backend**: Node.js with Express.js for API development. Use it to handle routes, middleware for authentication, and database interactions.
- **Database**: SQLite for lightweight, file-based storage. Ideal for this project as it requires no server setup. Use an ORM like Sequelize or raw SQL queries via `sqlite3` package.
- **Frontend**: React.js for building dynamic UIs. Use hooks for state management, React Router for navigation, and libraries like Axios for API calls.
- **Additional Libraries** (optional but recommended):
    - Backend: `bcrypt` for password hashing, `jsonwebtoken` (JWT) for authentication, `body-parser` for request parsing.
    - Frontend: `react-router-dom` for routing, `formik` or similar for form handling and validation, `antd` or `material-ui` for UI components (keep it simple if preferred).
    - Cross-cutting: `cors` for enabling frontend-backend communication.

Setup tip: Initialize the project with separate folders for backend and frontend. Use `create-react-app` for the frontend and `express-generator` or manual setup for the backend. Run them concurrently (e.g., via `concurrently` package).

---

## Database Schema Design

Design a normalized schema to avoid redundancy and ensure data integrity. Use SQLite's features like foreign keys for relationships.

### Suggested Tables

1. **Users** (Stores all user data, including admins, normal users, and store owners)
    - `id`: INTEGER PRIMARY KEY AUTOINCREMENT
    - `name`: TEXT NOT NULL (min 20 chars, max 60 chars)
    - `email`: TEXT UNIQUE NOT NULL (validated as email)
    - `password`: TEXT NOT NULL (hashed; 8-16 chars with uppercase and special char)
    - `address`: TEXT (max 400 chars)
    - `role`: TEXT NOT NULL (enum-like: 'admin', 'user', 'owner')
2. **Stores** (Stores registered on the platform, owned by users with 'owner' role)
    - `id`: INTEGER PRIMARY KEY AUTOINCREMENT
    - `name`: TEXT NOT NULL (min 20 chars, max 60 chars)
    - `email`: TEXT UNIQUE NOT NULL (validated as email)
    - `address`: TEXT (max 400 chars)
    - `owner_id`: INTEGER REFERENCES Users(id) ON DELETE CASCADE (links to a Store Owner user)
3. **Ratings** (User-submitted ratings for stores)
    - `id`: INTEGER PRIMARY KEY AUTOINCREMENT
    - `user_id`: INTEGER REFERENCES Users(id) ON DELETE CASCADE
    - `store_id`: INTEGER REFERENCES Stores(id) ON DELETE CASCADE
    - `rating`: INTEGER NOT NULL (1-5)
    - `created_at`: DATETIME DEFAULT CURRENT_TIMESTAMP
    - UNIQUE (user_id, store_id) to prevent duplicate ratings per user-store pair (allow updates via replacement)

### Schema Best Practices

- **Normalization**: Separate users, stores, and ratings to avoid data duplication.
- **Indexes**: Add indexes on frequently queried fields like `email` in Users, `name` in Stores, and `store_id` in Ratings for faster searches.
- **Constraints**: Enforce uniqueness (e.g., emails) and foreign keys.
- **Migrations**: Use a script to create tables on app start or via a migration tool.
- **Calculated Fields**: Don't store average ratings in Stores; compute them dynamically via SQL queries (e.g., `AVG(rating)` GROUP BY store_id).
- **Potential Extension**: If a store owner can own multiple stores, adjust the schema accordingly (but requirements suggest one-to-one for simplicity).

Example SQL for table creation (in backend init script):

```sql
CREATE TABLE Users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    address TEXT,
    role TEXT NOT NULL
);
-- Similar for Stores and Ratings
```

---

## Backend Design (Node.js + Express.js)

Build a RESTful API to handle all operations. Use middleware for authentication (e.g., JWT after login) and authorization (check role in requests).

### Authentication and Authorization

- Implement JWT: On login, verify credentials and issue a token with user ID and role.
- Middleware: Protect routes with `authMiddleware` that verifies token and attaches user data to req.
- Password Handling: Always hash passwords with bcrypt before storing.
- Sessions: Alternative to JWT, but JWT is stateless and simpler for this scale.

### Suggested API Endpoints

Group endpoints by role/functionality for organization.

- **Auth Routes** (Public):
    - POST `/api/auth/signup`: For Normal Users (validate fields, hash password, insert into Users with role 'user').
    - POST `/api/auth/login`: Verify email/password, return JWT.
    - POST `/api/auth/logout`: Client-side token removal (no server action needed).
    - PATCH `/api/auth/update-password`: Authenticated; update user's password (validate old/new).
- **Admin Routes** (Protected; role='admin'):
    - POST `/api/admin/users`: Add new user (any role; validate fields).
    - GET `/api/admin/dashboard`: Fetch totals (users count, stores count, ratings count).
    - GET `/api/admin/stores`: List stores with name, email, address, average rating (support filters/sort via query params).
    - POST `/api/admin/stores`: Add new store (assign owner_id if applicable).
    - GET `/api/admin/users`: List users with name, email, address, role (support filters/sort).
    - GET `/api/admin/users/:id`: View user details (include store rating if role='owner').
- **User Routes** (Protected; role='user'):
    - GET `/api/user/stores`: List stores with name, address, overall rating, user's rating (join Ratings), search by name/address.
    - POST `/api/user/ratings`: Submit rating for a store (1-5; insert or update in Ratings).
    - PATCH `/api/user/ratings/:storeId`: Modify existing rating.
- **Owner Routes** (Protected; role='owner'):
    - GET `/api/owner/dashboard`: Get average rating and list of raters (users who rated their store).

### Query Params for Filters/Sorting

- Use query params like `?name=partial&email=exact&sort=name:asc&role=user`.
- In Express, parse params and build dynamic SQL queries (use prepared statements to prevent SQL injection).

### Best Practices

- Error Handling: Use try-catch, return meaningful HTTP codes (e.g., 400 for validation errors).
- Validation: Use `joi` or `express-validator` for input validation.
- Logging: Console.log for dev; consider Winston for production.
- CORS: Enable for frontend origin.
- Rate Limiting: Optional, but good for login endpoints.

---

## Frontend Design (React.js)

Build a single-page application (SPA) with role-based routing. Use React Router to redirect based on role after login.

### Component Structure

- **Shared Components**: Header (with logout), Footer, Form Components (with validation).
- **Auth Pages**: LoginForm, SignupForm (for Normal Users).
- **Admin Dashboard**: Stats cards (totals), Tables for users/stores (with filters, sorting via libraries like `react-table`).
- **User Dashboard**: Store list (search bar, rating submission via stars or dropdown), Profile for password update.
- **Owner Dashboard**: Rating summary, Rater list.

### State Management

- Use Context API or Redux for global state (e.g., user auth data).
- Local state with `useState` for forms.

### UI/UX Tips

- Tables: Support sorting (click headers) and pagination if lists are long.
- Forms: Use libraries for validation (e.g., Yup with Formik) matching backend rules.
- Ratings: Display as stars (e.g., via `react-rating`).
- Responsiveness: Use CSS-in-JS or Bootstrap for mobile-friendly design.
- Navigation: Post-login, redirect to role-specific dashboard (e.g., /admin, /user, /owner).

### API Integration

- Use Axios with interceptors for JWT headers.
- Handle loading states and errors (e.g., toast notifications).

## Form Validations

Apply these consistently on frontend (for UX) and backend (for security):

- **Name**: 20-60 chars, alphanumeric.
- **Address**: Up to 400 chars, no special restrictions beyond length.
- **Password**: 8-16 chars, regex for uppercase (`[A-Z]`) and special char (`[!@#$%^&*]`).
- **Email**: Use regex like `/^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/`.
- Frontend: Prevent submission on invalid; show errors.
- Backend: Re-validate to catch tampering.

---

## Additional Best Practices

- **Security**: Hash passwords, use HTTPS in prod, sanitize inputs.
- **Performance**: Optimize queries (e.g., use JOINs for ratings), lazy-load components.
- **Code Quality**: ESLint/Prettier for formatting, modular files, comments.
- **Testing/Deployment**: Test locally, consider deploying to Heroku/Vercel for demo.
- **Edge Cases**: Handle no ratings (show 0 or N/A), duplicate emails, invalid roles.
- **Accessibility**: Add ARIA labels, keyboard navigation.

---

## Submission Guidelines

- Provide a GitHub repository with the complete codebase.
- Include a `README.md` with:
    - Setup instructions (e.g., `npm install`, database setup).
    - API documentation (endpoints, request/response formats).
    - Screenshots or a demo link (if hosted).
- Ensure the application is fully functional and meets all requirements.
- Test thoroughly for edge cases and validations.

---